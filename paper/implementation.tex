\section{Implementation}
\label{sec:implementation}

The fundamental problem is the lack of comparisons between the different mechanisms for capability based access control mechanisms, since most systems are designed to address the requirements of a target application. For this we recognized the lack of and therein need for a standard workload to evaluate the performance of these systems against, a form of a benchmark workload. While it would not be ideal for us to design the gold benchmark for this purpose, we created a workload generation mechanism by using our own workload language, so that we can generate workloads customizable to our requirements.

The language is composed of the following 6 instructions :
\begin{itemize}
\item createc $\langle$client name$\rangle$ $\langle$list of resources$\rangle$
\item creater $\langle$resource name$\rangle$
\item access $\langle$client name$\rangle$ $\langle$resource name$\rangle$
\item removec $\langle$client name$\rangle$
\item remover $\langle$resource name$\rangle$
\item revoke $\langle$client name$\rangle$ $\langle$list of resources$\rangle$
\end{itemize}   
Although we did limit revocation to a time out mechanism and hence did not make use of that instruction.

With respect to our model, we tried to implement the capability types mentioned in Section: \ref{sec:Introduction}. The key participants of the system are: issuer which is an authority granting the capability tokens, the subject which is a client requesting the access to a resource, and device which is the actual resource in question. Based on this framework, the basic formation of the different types or modes would be as follows:
\begin{enumerate}
\item Mode 1 (Tagged with tag bits):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer gives token to subject
		\item subject requests device by sending token (w/ metadata)
		\item device responds
	\end{enumerate}
	
\item Mode 2 (Tagged with type system):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer gives token number to subject, and capability to device
		\item subject requests device by sending simple token
		\item device looks at relevant capability metadata; responds
	\end{enumerate}

\item Mode 3 (Segregated):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer keeps capability itself; replies with token
		\item subject requests device via issuer, sending token and identifying itself
		\item issuer establishes connection between subject and device
	\end{enumerate}

\item Mode 4 (Password/sparse):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer keeps cap itself; replies with token and password
		\item subject requests device via issuer, sending token and password
		\item issuer establishes connection between subject and device
	\end{enumerate}
\end{enumerate}

We implemented this design in C++ using RapidJSON \footnote{http://rapidjson.org/} for parsing and generating the capability tokens. In order to obtain secure connection between the issuer/ subject/ devices, we implemented the SSL protocol using the general purpose cryptography library \footnote{https://www.openssl.org/}. To simplify the workload used in our design, we consider the devices/ resources to be a plain text file. In the following section we discuss the results we obtained by running our capBAC system in Mode1 and Mode2. 

\section{Results}
\label{sec:results}