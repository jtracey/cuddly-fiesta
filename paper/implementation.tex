\section{Implementation}
\label{sec:implementation}

The fundamental problem with the current state of capabilities is the lack of comparisons between the different mechanisms for capability based access control mechanisms, since most systems are designed to address the requirements of a target application. For this, we recognized the lack of and the need for a standard workload to evaluate the performance of these systems against, a form of a benchmark workload. While it would not be ideal for us to design the gold benchmark for this purpose, we created a workload generation mechanism by using our own workload language, so that we can generate workloads customizable to our requirements.

The language is composed of the following 6 instructions, which are generalizable to most access control:
\begin{itemize}
\item createc $\langle$client name$\rangle$ $\langle$list of resources$\rangle$
\item creater $\langle$resource name$\rangle$
\item access $\langle$client name$\rangle$ $\langle$resource name$\rangle$
\item removec $\langle$client name$\rangle$
\item remover $\langle$resource name$\rangle$
\item revoke $\langle$client name$\rangle$ $\langle$list of resources$\rangle$
\end{itemize}   
Revocation was limited to a time out mechanism for our implementation, and hence there was never use of the revoke instructions, since it does not generalize to all capability systems (e.g. the original version of CapBAC has no explicit revocation).

With respect to our model, we tried to implement the capability types mentioned in Section I. The key participants of the system are: an issuer which is an authority granting the capability tokens, the subject which is a client requesting the access to a resource, and a device which is the actual resource in question. Based on this framework, the basic formation of the different types or modes would be as follows:
\begin{enumerate}
\item Mode 1 (Tagged with tag bits):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer gives token to subject
		\item subject requests device by sending token (w/ metadata)
		\item device responds
	\end{enumerate}
	
\item Mode 2 (Tagged with type system):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer gives token number to subject, and capability to device
		\item subject requests device by sending simple token
		\item device looks at relevant capability metadata; responds
	\end{enumerate}

\item Mode 3 (Segregated):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer keeps capability itself; replies with token
		\item subject requests device via issuer, sending token and identifying itself
		\item issuer establishes connection between subject and device
	\end{enumerate}

\item Mode 4 (Password/sparse):
	\begin{enumerate}
		\item subject requests capability from issuer
		\item issuer keeps cap itself; replies with token and password
		\item subject requests device via issuer, sending token and password
		\item issuer establishes connection between subject and device
	\end{enumerate}
\end{enumerate}

We implemented this design in C++ using RapidJSON for parsing and generating the capability tokens.~\footnote{http://rapidjson.org/} In order to obtain secure connection between the issuer/subject/devices, we used the openSSL toolkit.~\footnote{https://www.openssl.org/} To simplify the workload used in our design, we consider the resources to be character strings. The implementation code can be found at \href{https://github.com/jtracey/cuddly-fiesta}{https://github.com/jtracey/cuddly-fiesta}. In the following section we discuss the results we obtained by running our capBAC system in Mode1 and Mode2.
\section{Results}
\label{sec:results}

