\subsection{L4}
\label{subsec:L4}
L4 is a family of microkernels, originally based on the L3 microkernel. Much in the same way that Unix was originally a single OS but now often refers to a style or family of OSs, so is L4 both a single microkernel OS from 1994, and a wide family of kernels which are based on its design.~\cite{elphinstone2013}

Many of the advances in capability-based systems as applied to operating systems originate in the L4 family, originating from a shift around 2008 that created an emphasis in greater security and safety than alternative operating systems. Capability-based systems were added to the OKL4 kernel, and then to the Fiasco.OC kernel (both of which being in the L4 family) as their new primary access control mechanism, in attempt to provide greater security. However, due to a growing desire to create a formally verified OS, and the infeasibility of doing so without starting from a code base intended for it, an entirely new L4 kernel was written in 2013: seL4. With a kernel written in C ported from Haskell,\footnote{As an interesting aside, a Linux-compatible user space for seL4 is being built in Rust.} it is considered to be the first formally verified general-purpose OS. Integral to this formal verification is the capability system that it is built around.

Both due to the nature of being a microkernel, and to aid in the task of formal verification, seL4 makes every effort to minimize the services that are contained in the kernel. In the capability system that seL4 is built around, there are 6 fundamental categories of objects in the kernel:~\cite{kuz2010, sewell2011}
\begin{enumerate}
\item {\bf Capabilities:} Capabilities themselves are objects in the seL4 kernel. These objects are stored in what are called {\em CNodes}. When a CNode is created, it is given a fixed number of capability ``slots'' that store capabilities. As capabilities are objects, one capability a CNode may store in one of its slots is another CNode, forming a linked set of CNodes that is called the {\em CSpace}. For a thread (which, as described in more detail later, are the subjects of seL4's capability system) to have a certain capability on a particular object, that object must be stored somewhere in the thread's CSpace.
\item {\bf Objects/memory:} All objects and memory start as what are called {\em Untyped Memory} capabilities, which can be thought of as a blank-slate for a potential capability. When a new object is created or memory is allocated, the Untyped Memory has the {\em retype} method invoked on it, which will create the desired object or allocate the desired memory (if granted). Conversely, {\em revoke} is used to remove previously granted capabilities.
\item {\bf Virtual address space:} In a structure largely similar to that of CSpace, virtual memory addresses are managed in what is called a {\em VSpace}. How the VSpace is structured specifically depends on the processor architecture. In the case of IA32 and ARM architectures, the root of a VSpace is a {\em Page Directory} object, which points to {\em Page Table} objects. These Page Table objects then point to specific regions of physical memory, which are represented as {\em Frame} objects.
\item {\bf Thread Control Block (TCB):} Threads are the subjects of the seL4 capability system. Each thread has a designated TCB object, which is used by the kernel for controlling the thread (e.g. scheduling). Most importantly for our purposes, the TCB is what designates the thread's CSpace and VSpace roots. When a thread wishes to use a capability, it presents the kernel the respective capability in its CSpace. As a result, seL4 uses a capability system that falls into the Segregated category, described in Section I.
\item {\bf Endpoints (EP):} Inter-Process Communication (IPC) in seL4 is done using EP objects that facilitate message passing. These Endpoints can be either synchronous or asynchronous in nature, with the synchronous Endpoints being used for transferring data between threads, as well as capabilities if the sender has the {\em Grant} right on the EP. Asynchronous EPs are used primarily for simple notifications.
\item {\bf Device I/O:} As a microkernel, device drivers run in user space and do not require a kernel object themselves. However, in order to provide access to lower-level hardware that the drivers may need, such as DMA address spaces, I/O ports, and interrupts, objects specific to these resources are available.
\end{enumerate}

The structure of this capability system has been used not only to successfully engage in formal verification of the entire kernel, but it has also been used as the basis of at least one other OS: Barrelfish.
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
